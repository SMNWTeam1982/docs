{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for FRC Team 1982 Project docs, standards, philosophy etc.","title":"Home"},{"location":"#documentation-for-frc-team-1982","text":"Project docs, standards, philosophy etc.","title":"Documentation for FRC Team 1982"},{"location":"hardware/swerve-drive-prep/","text":"Getting the robot set up Remove the bumper and make sure that the swerve modules are free, they should be able to rotate freely Your life will be easier if the robot is higher up (use the pump cart) set up the phoenix tuner open phoenix tuner X and the drivers station at the same time open the menu using the left hand side in the menu where it says to enter a team number or IP enter the text \"Driver Station\" the software might prompt you to run a temporary diagnostics server if it does then deploy it the exact hardware might vary from year to year but you should see 4 encoders prep the robot this link shows what the robot coordinate system is and is important for tuning the encoders to give a correct output https://docs.wpilib.org/en/stable/docs/software/basic-programming/coordinate-system.html zero the encoders swerve modules are asymmetric, each wheel has a bevel gear on one side, when zeroing the encoders the bevel gears should all be facing the same direction","title":"Preparing the Swerve Drives"},{"location":"hardware/swerve-drive-prep/#getting-the-robot-set-up","text":"Remove the bumper and make sure that the swerve modules are free, they should be able to rotate freely Your life will be easier if the robot is higher up (use the pump cart)","title":"Getting the robot set up"},{"location":"hardware/swerve-drive-prep/#set-up-the-phoenix-tuner","text":"open phoenix tuner X and the drivers station at the same time open the menu using the left hand side in the menu where it says to enter a team number or IP enter the text \"Driver Station\" the software might prompt you to run a temporary diagnostics server if it does then deploy it the exact hardware might vary from year to year but you should see 4 encoders","title":"set up the phoenix tuner"},{"location":"hardware/swerve-drive-prep/#prep-the-robot","text":"this link shows what the robot coordinate system is and is important for tuning the encoders to give a correct output https://docs.wpilib.org/en/stable/docs/software/basic-programming/coordinate-system.html","title":"prep the robot"},{"location":"hardware/swerve-drive-prep/#zero-the-encoders","text":"swerve modules are asymmetric, each wheel has a bevel gear on one side, when zeroing the encoders the bevel gears should all be facing the same direction","title":"zero the encoders"},{"location":"philosophy/on-command-based-programming/","text":"For the 2023 & 2024 seasons we used command based, before that I dont know. The code for those seasons was spagetti, Initially we tried both of those years to write the code in a command based way but as the season progressed and our goal was to just get things working, the command based stuff just got in our way and we ended up just working around the command based stuff. wpilib explenation of command-based programming: https://docs.wpilib.org/en/stable/docs/software/commandbased/what-is-command-based.html Pros and cons of NOT doing command-based Pros: writing code is fast, this is the biggest benefit of not doing command-based the style of coding used when not doing command-based is the same style that many people are already familiar with Can write code in this way without being experienced in the programming language very easy to write TeleOp code We can handle when things are run directly, instead of having to go through the command scheduler Extra verbose Cons: Most teams use command-based pathplanner expects you to use command-based, using pathplanner requires extra effort A little difficult to write Auto code can accidentally create a conflict where 2 pieces of code tell 1 piece of hardware to do something Pros and cons of doing command based Pros: plenty of examples because most teams use command-based Very easy to write Auto code / sequential code Can avoid conflicts via the command requirments Well written command-based code looks really nice Uses factory functions and lambdas to run code (makes for concise code, concise code can be easier to follow) Cons: Hard to work with when crunched for time Command scheduler is confusing TeleOp code can be convoluted hard to write code that uses multiple subsystems at the same time Uses factory functions and lambdas to run code (these are very confusing, even more for new programmers)","title":"On Command Based Programming"},{"location":"philosophy/on-command-based-programming/#pros-and-cons-of-not-doing-command-based","text":"","title":"Pros and cons of NOT doing command-based"},{"location":"philosophy/on-command-based-programming/#pros","text":"writing code is fast, this is the biggest benefit of not doing command-based the style of coding used when not doing command-based is the same style that many people are already familiar with Can write code in this way without being experienced in the programming language very easy to write TeleOp code We can handle when things are run directly, instead of having to go through the command scheduler Extra verbose","title":"Pros:"},{"location":"philosophy/on-command-based-programming/#cons","text":"Most teams use command-based pathplanner expects you to use command-based, using pathplanner requires extra effort A little difficult to write Auto code can accidentally create a conflict where 2 pieces of code tell 1 piece of hardware to do something","title":"Cons:"},{"location":"philosophy/on-command-based-programming/#pros-and-cons-of-doing-command-based","text":"","title":"Pros and cons of doing command based"},{"location":"philosophy/on-command-based-programming/#pros_1","text":"plenty of examples because most teams use command-based Very easy to write Auto code / sequential code Can avoid conflicts via the command requirments Well written command-based code looks really nice Uses factory functions and lambdas to run code (makes for concise code, concise code can be easier to follow)","title":"Pros:"},{"location":"philosophy/on-command-based-programming/#cons_1","text":"Hard to work with when crunched for time Command scheduler is confusing TeleOp code can be convoluted hard to write code that uses multiple subsystems at the same time Uses factory functions and lambdas to run code (these are very confusing, even more for new programmers)","title":"Cons:"},{"location":"philosophy/on-package-management/","text":"On Package Management Managing dependencies when programming is tricky, and Python doesn't make it fun. Python standardizes Pip and the way it works, but it's not terribly complex and doesn't handle more advanced concepts like Virtual Environments. It can also break packages (system installed or otherwise) very easily, and despite being usable in most cases, further extension is necessary. I have decided that an extended package manager is needed to effectively work with Python and FRC code, and so I write this to expand on what and how to use the abstractions defined in our standards. Pipenv vs Pip I decided, after a little searching, that Pipenv complied with the warrants that an FRC and RobotPy project needs. In terms of functionality, Pipenv has a few things that, in my opinion, make it a little more usable for this purpose. Pipenv, among other things, uses a standard configuration to define packages and configuration for build and deploy scripts. It also automatically handles the creation and management of Virtual Environments, which prevents Robot Code and dependencies from interfering with anything else installed on any given computer. See below figure 1 and figure 2 which show the pros and cons of Pip, briefly summarized. There are many more nuances that are necessary to understand, but those are outlined in programming/pipenv Pipenv (Figure 1) Pros Cons Virtual Environments Much more complex than Pip Scripts in Configuration More documentation work necessary (nonstandard) Pip (Figure 2) Pros Cons Simple and easy to use Can easily break system HIGHLY documented and used in RobotPy/WPI docs Lacks certain configuration features Why not Poetry, PDM, etc? I chose Pipenv on a whim, honestly. But after reading about some features of Pipenv when compared with Poetry and some others, I found that it would have an easy enough learning curve and has sufficient features when compared with it's contemporaries in other languages (see NPM, Cargo, etc) zach is making me write this - kay","title":"On Package Management"},{"location":"philosophy/on-package-management/#on-package-management","text":"Managing dependencies when programming is tricky, and Python doesn't make it fun. Python standardizes Pip and the way it works, but it's not terribly complex and doesn't handle more advanced concepts like Virtual Environments. It can also break packages (system installed or otherwise) very easily, and despite being usable in most cases, further extension is necessary. I have decided that an extended package manager is needed to effectively work with Python and FRC code, and so I write this to expand on what and how to use the abstractions defined in our standards.","title":"On Package Management"},{"location":"philosophy/on-package-management/#pipenv-vs-pip","text":"I decided, after a little searching, that Pipenv complied with the warrants that an FRC and RobotPy project needs. In terms of functionality, Pipenv has a few things that, in my opinion, make it a little more usable for this purpose. Pipenv, among other things, uses a standard configuration to define packages and configuration for build and deploy scripts. It also automatically handles the creation and management of Virtual Environments, which prevents Robot Code and dependencies from interfering with anything else installed on any given computer. See below figure 1 and figure 2 which show the pros and cons of Pip, briefly summarized. There are many more nuances that are necessary to understand, but those are outlined in programming/pipenv","title":"Pipenv vs Pip"},{"location":"philosophy/on-package-management/#pipenv-figure-1","text":"Pros Cons Virtual Environments Much more complex than Pip Scripts in Configuration More documentation work necessary (nonstandard)","title":"Pipenv (Figure 1)"},{"location":"philosophy/on-package-management/#pip-figure-2","text":"Pros Cons Simple and easy to use Can easily break system HIGHLY documented and used in RobotPy/WPI docs Lacks certain configuration features","title":"Pip (Figure 2)"},{"location":"philosophy/on-package-management/#why-not-poetry-pdm-etc","text":"I chose Pipenv on a whim, honestly. But after reading about some features of Pipenv when compared with Poetry and some others, I found that it would have an easy enough learning curve and has sufficient features when compared with it's contemporaries in other languages (see NPM, Cargo, etc) zach is making me write this - kay","title":"Why not Poetry, PDM, etc?"},{"location":"philosophy/on-the-importance-of-documentation/","text":"If everyone on the team suddenly disappeared and were replaced with someone with no experience, would they be able to pick up where you left off? would they have to learn everything from scratch? Documenting what you do and what you learn is VERY important for the success of the team. Future members of the team should not have to go through all of the experiences that you went through to get to your knowledge level.","title":"On the Importance of Documentation"},{"location":"programming/button-box-template/","text":"Button Box Code Template This is a general outline for creating an X-Input emulator with a Teensy Arduino Board What you Will Need 32 Bit PJRC Teensy (or clone) with USB Support Arduino IDE with Teensyduino installed Buttons! Code This code is a template from the Teensyduino library with USB Joystick support, it should work out of the box with Teensyduino. This assigns DIO pins 1-9 as X-Input buttons that should be discovered as a controller on code upload. This will work out of the box with Driver Station because it is emulating an Xbox controller. CPP Example Code //This code is in C++ and is for coding a button box using Arduino IDE //As of now (2025) we are using a Teensy 3.2 Board and using Teensyduino //with Arduino IDE //This is the code //Source: https://www.partsnotincluded.com/how-to-emulate-an-xbox-controller-with-arduino-xinput/ //This is a modified version of the USB_Joystick Button Example code /* Buttons to USB Joystick Example You must select Joystick from the \"Tools > USB Type\" menu This example code is in the public domain. */ #include <Bounce.h> // Create Bounce objects for each button. The Bounce object // automatically deals with contact chatter or \"bounce\", and // it makes detecting changes very simple. Bounce button1 = Bounce(1, 10); // 10 = 10 ms debounce time Bounce button2 = Bounce(2, 10); // which is appropriate for Bounce button3 = Bounce(3, 10); // most mechanical pushbuttons Bounce button4 = Bounce(4, 10); Bounce button5 = Bounce(5, 10); Bounce button6 = Bounce(6, 10); Bounce button7 = Bounce(7, 10); Bounce button8 = Bounce(8, 10); Bounce button9 = Bounce(9, 10); void setup() { // Configure the pins for input mode with pullup resistors. // The pushbuttons connect from each pin to ground. When // the button is pressed, the pin reads LOW because the button // shorts it to ground. When released, the pin reads HIGH // because the pullup resistor connects to +5 volts inside // the chip. LOW for \"on\", and HIGH for \"off\" may seem // backwards, but using the on-chip pullup resistors is very // convenient. The scheme is called \"active low\", and it's // very commonly used in electronics... so much that the chip // has built-in pullup resistors! pinMode(1, INPUT_PULLUP); pinMode(2, INPUT_PULLUP); pinMode(3, INPUT_PULLUP); pinMode(4, INPUT_PULLUP); pinMode(5, INPUT_PULLUP); pinMode(6, INPUT_PULLUP); // Teensy++ LED, may need 1k resistor pullup pinMode(7, INPUT_PULLUP); pinMode(8, INPUT_PULLUP); pinMode(9, INPUT_PULLUP); // Please be aware the X, Y, Z, Zr and Slider axes will have default // settings, if you only use the buttons. This can give the appearance // of the buttons interfering with the axes, if your PC software shows // different default assumed values before your first button press. // More details here: // https://forum.pjrc.com/threads/29320-Teensy-3-1-Button-problems?p=80275#post80275 } void loop() { // Update all the buttons. There should not be any long // delays in loop(), so this runs repetitively at a rate // faster than the buttons could be pressed and released. button1.update(); button2.update(); button3.update(); button4.update(); button5.update(); button6.update(); button7.update(); button8.update(); button9.update(); // Check each button for \"falling\" edge. // Update the Joystick buttons only upon changes. // falling = high (not pressed - voltage from pullup resistor) // to low (pressed - button connects pin to ground) if (button1.fallingEdge()) { Joystick.button(1, 1); } if (button2.fallingEdge()) { Joystick.button(2, 1); } if (button3.fallingEdge()) { Joystick.button(3, 1); } if (button4.fallingEdge()) { Joystick.button(4, 1); } if (button5.fallingEdge()) { Joystick.button(5, 1); } if (button6.fallingEdge()) { Joystick.button(6, 1); } if (button7.fallingEdge()) { Joystick.button(7, 1); } if (button8.fallingEdge()) { Joystick.button(8, 1); } if (button9.fallingEdge()) { Joystick.button(9, 1); } // Check each button for \"rising\" edge // Update the Joystick buttons only upon changes. // rising = low (pressed - button connects pin to ground) // to high (not pressed - voltage from pullup resistor) if (button1.risingEdge()) { Joystick.button(1, 0); } if (button2.risingEdge()) { Joystick.button(2, 0); } if (button3.risingEdge()) { Joystick.button(3, 0); } if (button4.risingEdge()) { Joystick.button(4, 0); } if (button5.risingEdge()) { Joystick.button(5, 0); } if (button6.risingEdge()) { Joystick.button(6, 0); } if (button7.risingEdge()) { Joystick.button(7, 0); } if (button8.risingEdge()) { Joystick.button(8, 0); } if (button9.risingEdge()) { Joystick.button(9, 0); } } Wiring By default, the above code uses DIO pins 1-9 on any given Teensy board, and so the buttons should be wired to a common ground (GND) on one side, and any of the pins 1-9 on the opposite contact of the button. The code automatically handles debouncing, meaning the only necessary wiring is directly from the button to ground on one side and to the DIO pin on the other side.xw","title":"Button Box Template"},{"location":"programming/button-box-template/#button-box-code-template","text":"This is a general outline for creating an X-Input emulator with a Teensy Arduino Board","title":"Button Box Code Template"},{"location":"programming/button-box-template/#what-you-will-need","text":"32 Bit PJRC Teensy (or clone) with USB Support Arduino IDE with Teensyduino installed Buttons!","title":"What you Will Need"},{"location":"programming/button-box-template/#code","text":"This code is a template from the Teensyduino library with USB Joystick support, it should work out of the box with Teensyduino. This assigns DIO pins 1-9 as X-Input buttons that should be discovered as a controller on code upload. This will work out of the box with Driver Station because it is emulating an Xbox controller. CPP Example Code //This code is in C++ and is for coding a button box using Arduino IDE //As of now (2025) we are using a Teensy 3.2 Board and using Teensyduino //with Arduino IDE //This is the code //Source: https://www.partsnotincluded.com/how-to-emulate-an-xbox-controller-with-arduino-xinput/ //This is a modified version of the USB_Joystick Button Example code /* Buttons to USB Joystick Example You must select Joystick from the \"Tools > USB Type\" menu This example code is in the public domain. */ #include <Bounce.h> // Create Bounce objects for each button. The Bounce object // automatically deals with contact chatter or \"bounce\", and // it makes detecting changes very simple. Bounce button1 = Bounce(1, 10); // 10 = 10 ms debounce time Bounce button2 = Bounce(2, 10); // which is appropriate for Bounce button3 = Bounce(3, 10); // most mechanical pushbuttons Bounce button4 = Bounce(4, 10); Bounce button5 = Bounce(5, 10); Bounce button6 = Bounce(6, 10); Bounce button7 = Bounce(7, 10); Bounce button8 = Bounce(8, 10); Bounce button9 = Bounce(9, 10); void setup() { // Configure the pins for input mode with pullup resistors. // The pushbuttons connect from each pin to ground. When // the button is pressed, the pin reads LOW because the button // shorts it to ground. When released, the pin reads HIGH // because the pullup resistor connects to +5 volts inside // the chip. LOW for \"on\", and HIGH for \"off\" may seem // backwards, but using the on-chip pullup resistors is very // convenient. The scheme is called \"active low\", and it's // very commonly used in electronics... so much that the chip // has built-in pullup resistors! pinMode(1, INPUT_PULLUP); pinMode(2, INPUT_PULLUP); pinMode(3, INPUT_PULLUP); pinMode(4, INPUT_PULLUP); pinMode(5, INPUT_PULLUP); pinMode(6, INPUT_PULLUP); // Teensy++ LED, may need 1k resistor pullup pinMode(7, INPUT_PULLUP); pinMode(8, INPUT_PULLUP); pinMode(9, INPUT_PULLUP); // Please be aware the X, Y, Z, Zr and Slider axes will have default // settings, if you only use the buttons. This can give the appearance // of the buttons interfering with the axes, if your PC software shows // different default assumed values before your first button press. // More details here: // https://forum.pjrc.com/threads/29320-Teensy-3-1-Button-problems?p=80275#post80275 } void loop() { // Update all the buttons. There should not be any long // delays in loop(), so this runs repetitively at a rate // faster than the buttons could be pressed and released. button1.update(); button2.update(); button3.update(); button4.update(); button5.update(); button6.update(); button7.update(); button8.update(); button9.update(); // Check each button for \"falling\" edge. // Update the Joystick buttons only upon changes. // falling = high (not pressed - voltage from pullup resistor) // to low (pressed - button connects pin to ground) if (button1.fallingEdge()) { Joystick.button(1, 1); } if (button2.fallingEdge()) { Joystick.button(2, 1); } if (button3.fallingEdge()) { Joystick.button(3, 1); } if (button4.fallingEdge()) { Joystick.button(4, 1); } if (button5.fallingEdge()) { Joystick.button(5, 1); } if (button6.fallingEdge()) { Joystick.button(6, 1); } if (button7.fallingEdge()) { Joystick.button(7, 1); } if (button8.fallingEdge()) { Joystick.button(8, 1); } if (button9.fallingEdge()) { Joystick.button(9, 1); } // Check each button for \"rising\" edge // Update the Joystick buttons only upon changes. // rising = low (pressed - button connects pin to ground) // to high (not pressed - voltage from pullup resistor) if (button1.risingEdge()) { Joystick.button(1, 0); } if (button2.risingEdge()) { Joystick.button(2, 0); } if (button3.risingEdge()) { Joystick.button(3, 0); } if (button4.risingEdge()) { Joystick.button(4, 0); } if (button5.risingEdge()) { Joystick.button(5, 0); } if (button6.risingEdge()) { Joystick.button(6, 0); } if (button7.risingEdge()) { Joystick.button(7, 0); } if (button8.risingEdge()) { Joystick.button(8, 0); } if (button9.risingEdge()) { Joystick.button(9, 0); } }","title":"Code"},{"location":"programming/button-box-template/#wiring","text":"By default, the above code uses DIO pins 1-9 on any given Teensy board, and so the buttons should be wired to a common ground (GND) on one side, and any of the pins 1-9 on the opposite contact of the button. The code automatically handles debouncing, meaning the only necessary wiring is directly from the button to ground on one side and to the DIO pin on the other side.xw","title":"Wiring"},{"location":"programming/docs-reference/","text":"Documentation Reference All documentation for hardware should be from the official docs, as listed below:","title":"Documentation Reference"},{"location":"programming/docs-reference/#documentation-reference","text":"All documentation for hardware should be from the official docs, as listed below:","title":"Documentation Reference"},{"location":"programming/getting-started/","text":"From Zero to Swerve This is a basic introduction to initializing a RobotPy (WPILib Python) project to the spec of the team. I won't go in-depth on standards or code, but this will get a deployable 'Hello World!' to run on a RoboRIO. Other docs for actual swerve, hardware, etc are elsewhere. Prior to reading this, you should familiarize yourself with Pipenv and read up on some of the official docs, as well as our philosophies for programming and standards*. *Some of these pages are incomplete and not yet written. Initialize your Codebase Likely, you will be starting from something already, but this is assuming you aren't. For example, the swerve-template project which contains the basis of a swerve drive style drivetrain in Python. If you are not starting from a template, you will likely need to initialize the repository with pipenv . I will not document this here unless it becomes necessary, but the basic idea of creating a Git Repository from scratch and installing dependencies with pipenv is straightforward. Written by Kay, last updated 2/8/2025","title":"Getting Started"},{"location":"programming/getting-started/#from-zero-to-swerve","text":"This is a basic introduction to initializing a RobotPy (WPILib Python) project to the spec of the team. I won't go in-depth on standards or code, but this will get a deployable 'Hello World!' to run on a RoboRIO. Other docs for actual swerve, hardware, etc are elsewhere. Prior to reading this, you should familiarize yourself with Pipenv and read up on some of the official docs, as well as our philosophies for programming and standards*. *Some of these pages are incomplete and not yet written.","title":"From Zero to Swerve"},{"location":"programming/getting-started/#initialize-your-codebase","text":"Likely, you will be starting from something already, but this is assuming you aren't. For example, the swerve-template project which contains the basis of a swerve drive style drivetrain in Python. If you are not starting from a template, you will likely need to initialize the repository with pipenv . I will not document this here unless it becomes necessary, but the basic idea of creating a Git Repository from scratch and installing dependencies with pipenv is straightforward. Written by Kay, last updated 2/8/2025","title":"Initialize your Codebase"},{"location":"programming/pid-tuning-reference/","text":"General Reference for PID Tuning When you code looks like Add a negative sign to the values. then you should get something like","title":"PID Tuning Reference"},{"location":"programming/pid-tuning-reference/#general-reference-for-pid-tuning","text":"When you code looks like Add a negative sign to the values. then you should get something like","title":"General Reference for PID Tuning"},{"location":"programming/pipenv/","text":"Package Management with Pipenv The chosen package manager for Team 1982 programming is pipenv , as we explained in philosophy/On Package Management . This page documents the usage, nuances and applications of pipenv as it's used with our FRC code. Setting up Pipenv As our projects depend on Pipenv for local dependency management on development machines, it must be installed system-wide to be used effectively. Although the setup instructions are detailed on the pipenv documentation, the district-provided machines can be tricky to work with. View the below guides for your system, assuming a MacOS device is school provided. Windows Setup The Team 1982 programming computers are already properly configured for use with pipenv , but in the event that you want to use a personal device or need to reprovision the programming computers for any reason, the following guide should work. Install Python RobotPy requires a modern version of Python to function, as does pipenv. If you do not already have Python >=3.12 installed on your system, you may skip this step. If you need to install Python on your system, first open the Python download page and download te most recent version of Python 3.12 and follow through the installation steps. When installing, ensure the following boxes are checked if you reach an 'Optional Features' screen. (If you do not see this, look for an 'Advanced' or 'Customize installation' button.) Also ensure that an option for 'Add python.exe to path' is checked as it will make life easier down the line. Beyond this, the installation should be successful and you can move on to installing pipenv itself. Installing Pipenv Although not recommended, we make use of a system-wide installation of pipenv for managing our dependencies, meaning that you must ask pip to break system packages during the install. This sounds more scary than it is, as we will not be using the system pip install anymore. Open a powershell prompt and run python -m pip install --break-system-packages pipenv Which should fully install pipenv system-wide, and make it available from any command prompt (e.g. VSCode, Powershell, Windows Terminal). Now that pipenv is installed, you can move on to usage instructions. MacOS Setup Our goal is to make development as accessible as possible for our team's programmers, and as such, allow them to program on their district provided devices from anywhere. The district provided MacBook's are locked down to some extent, so there are some additional steps to take when installing. Installing Homebrew Although not necessary, installing Homebrew vastly improves the user experience of managing software on MacOS. The district provided MacBooks cannot install Homebrew per the traditional method, and must be installed manually. For more information on this, as well as a script to automate this process, see FloridaMan7588/Brewhax (WIP) . On non-managed systems, Homebrew can be installed by running the following in a terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 1^ After Homebrew has been installed, you can move on to Installing Python. Installing Python Brew vastly simplifies the installation of Python and Pipenv, which can be done by simply running brew install python@3.12 pipenv This installs all of the required dependencies for both Python and Pipenv. Beware that on system's with non-standard Homebrew install locations (e.g. using the script above), this may take a long time as several large packages have to compile. On M1 systems this may only take a few minutes. Linux Setup Although we do not use Linux on our primary machines, you may still want to at home or on one of the slower computers. In the case that you need to install Python or Pipenv, this varies by Distribution, but generally the packages follow the pattern of python3 python3-pipenv or some variation of that. On Ubuntu, for example, you can install both with sudo apt install python pipenv . From here, you can move on to usage instructions. For more information on the tooling we make use of, see programming/Tooling for setup instructions and usage information. Managing Software Dependencies The pipenv command is used in tandem with the Pipfile and Pipfile.lock to manage the installed dependencies within the virtual environment that pipenv manages. Installing Dependencies For managing what is installed in the development environment, pipenv install is provided to add packages and install existing packages specified in the Pipfile and lockfile. When adding dependencies to the project, they can either be added as development dependencies or as Robotpy dependencies. For development dependencies, they only need to be added to the Pipfile, which is done automatically when running pipenv install . Dependencies that need to be installed on the robot (Robotpy dependencies) must also be added to the pyproject.toml file, which can be done manually by editing the file. Removing Dependencies If the project no longer depends on a library, you can remove it from the project file with pipenv uninstall [package] , although it may still be present in the pyproject.toml and will thus be installed on the RoboRIO as well. If you wish to prevent installation on the RIO as well, remove the package from the pyproject file. Scripting Pipenv also supports scripts within the Pipfile, making it easy to execute repetitive commands without having to type them. By default, our swerve-template repository includes a Pipfile which has 4 commands predefined: - pipenv run sync - pipenv run deploy - pipenv run sim - pipenv run test These commands simplify the deploying of code to the robot and management of Robotpy dependencies. pipenv run sync The Sync command downloads the dependencies required for the RoboRIO to function, and must be re-run every time there is an update to pyproject.toml . The Sync command also prompts for updating dependencies, which should usually be ignored as this is managed by pipenv pipenv run deploy The Deploy command does exactly as it says, deploys the code to a connected RoboRIO. This command is platform agnostic, but the FRC Driver Station does not run on non-Windows platforms, so test with care. pipenv run sim The Sim command creates a realtime simulation of the Robot, although this is not fully supported and our code does not implement many of the sim features. pipenv run test The Test command runs the pyfrc test suite on the project to validate everything is setup correctly, and that the robot code will deploy withot errors. This is also automatically run on deploy. References Homebrew installation page Written by Kay, last updated 2/8/2025","title":"Package Management with Pipenv"},{"location":"programming/pipenv/#package-management-with-pipenv","text":"The chosen package manager for Team 1982 programming is pipenv , as we explained in philosophy/On Package Management . This page documents the usage, nuances and applications of pipenv as it's used with our FRC code.","title":"Package Management with Pipenv"},{"location":"programming/pipenv/#setting-up-pipenv","text":"As our projects depend on Pipenv for local dependency management on development machines, it must be installed system-wide to be used effectively. Although the setup instructions are detailed on the pipenv documentation, the district-provided machines can be tricky to work with. View the below guides for your system, assuming a MacOS device is school provided. Windows Setup The Team 1982 programming computers are already properly configured for use with pipenv , but in the event that you want to use a personal device or need to reprovision the programming computers for any reason, the following guide should work.","title":"Setting up Pipenv"},{"location":"programming/pipenv/#managing-software-dependencies","text":"The pipenv command is used in tandem with the Pipfile and Pipfile.lock to manage the installed dependencies within the virtual environment that pipenv manages.","title":"Managing Software Dependencies"},{"location":"programming/pipenv/#installing-dependencies","text":"For managing what is installed in the development environment, pipenv install is provided to add packages and install existing packages specified in the Pipfile and lockfile. When adding dependencies to the project, they can either be added as development dependencies or as Robotpy dependencies. For development dependencies, they only need to be added to the Pipfile, which is done automatically when running pipenv install . Dependencies that need to be installed on the robot (Robotpy dependencies) must also be added to the pyproject.toml file, which can be done manually by editing the file.","title":"Installing Dependencies"},{"location":"programming/pipenv/#removing-dependencies","text":"If the project no longer depends on a library, you can remove it from the project file with pipenv uninstall [package] , although it may still be present in the pyproject.toml and will thus be installed on the RoboRIO as well. If you wish to prevent installation on the RIO as well, remove the package from the pyproject file.","title":"Removing Dependencies"},{"location":"programming/pipenv/#scripting","text":"Pipenv also supports scripts within the Pipfile, making it easy to execute repetitive commands without having to type them. By default, our swerve-template repository includes a Pipfile which has 4 commands predefined: - pipenv run sync - pipenv run deploy - pipenv run sim - pipenv run test These commands simplify the deploying of code to the robot and management of Robotpy dependencies.","title":"Scripting"},{"location":"programming/pipenv/#pipenv-run-sync","text":"The Sync command downloads the dependencies required for the RoboRIO to function, and must be re-run every time there is an update to pyproject.toml . The Sync command also prompts for updating dependencies, which should usually be ignored as this is managed by pipenv","title":"pipenv run sync"},{"location":"programming/pipenv/#pipenv-run-deploy","text":"The Deploy command does exactly as it says, deploys the code to a connected RoboRIO. This command is platform agnostic, but the FRC Driver Station does not run on non-Windows platforms, so test with care.","title":"pipenv run deploy"},{"location":"programming/pipenv/#pipenv-run-sim","text":"The Sim command creates a realtime simulation of the Robot, although this is not fully supported and our code does not implement many of the sim features.","title":"pipenv run sim"},{"location":"programming/pipenv/#pipenv-run-test","text":"The Test command runs the pyfrc test suite on the project to validate everything is setup correctly, and that the robot code will deploy withot errors. This is also automatically run on deploy.","title":"pipenv run test"},{"location":"programming/pipenv/#references","text":"Homebrew installation page Written by Kay, last updated 2/8/2025","title":"References"},{"location":"programming/tools/","text":"Tooling","title":"Tooling"},{"location":"programming/tools/#tooling","text":"","title":"Tooling"},{"location":"standards/git-usage/","text":"","title":"Git Usage"},{"location":"standards/python-style-guide/","text":"","title":"Python Style Guide"}]}