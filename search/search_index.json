{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for FRC Team 1982 Project docs, standards, philosophy etc.","title":"Home"},{"location":"#documentation-for-frc-team-1982","text":"Project docs, standards, philosophy etc.","title":"Documentation for FRC Team 1982"},{"location":"hardware/swerve-drive-prep/","text":"Getting the robot set up Remove the bumper and make sure that the swerve modules are free, they should be able to rotate freely Your life will be easier if the robot is higher up (use the pump cart) set up the phoenix tuner open phoenix tuner X and the drivers station at the same time open the menu using the left hand side in the menu where it says to enter a team number or IP enter the text \"Driver Station\" the software might prompt you to run a temporary diagnostics server if it does then deploy it the exact hardware might vary from year to year but you should see 4 encoders prep the robot this link shows what the robot coordinate system is and is important for tuning the encoders to give a correct output https://docs.wpilib.org/en/stable/docs/software/basic-programming/coordinate-system.html zero the encoders swerve modules are asymmetric, each wheel has a bevel gear on one side, when zeroing the encoders the bevel gears should all be facing the same direction","title":"Preparing the Swerve Drives"},{"location":"hardware/swerve-drive-prep/#getting-the-robot-set-up","text":"Remove the bumper and make sure that the swerve modules are free, they should be able to rotate freely Your life will be easier if the robot is higher up (use the pump cart)","title":"Getting the robot set up"},{"location":"hardware/swerve-drive-prep/#set-up-the-phoenix-tuner","text":"open phoenix tuner X and the drivers station at the same time open the menu using the left hand side in the menu where it says to enter a team number or IP enter the text \"Driver Station\" the software might prompt you to run a temporary diagnostics server if it does then deploy it the exact hardware might vary from year to year but you should see 4 encoders","title":"set up the phoenix tuner"},{"location":"hardware/swerve-drive-prep/#prep-the-robot","text":"this link shows what the robot coordinate system is and is important for tuning the encoders to give a correct output https://docs.wpilib.org/en/stable/docs/software/basic-programming/coordinate-system.html","title":"prep the robot"},{"location":"hardware/swerve-drive-prep/#zero-the-encoders","text":"swerve modules are asymmetric, each wheel has a bevel gear on one side, when zeroing the encoders the bevel gears should all be facing the same direction","title":"zero the encoders"},{"location":"philosophy/on-command-based-programming/","text":"For the 2023 & 2024 seasons we used command based, before that I dont know. The code for those seasons was spagetti, Initially we tried both of those years to write the code in a command based way but as the season progressed and our goal was to just get things working, the command based stuff just got in our way and we ended up just working around the command based stuff. wpilib explenation of command-based programming: https://docs.wpilib.org/en/stable/docs/software/commandbased/what-is-command-based.html Pros and cons of NOT doing command-based Pros: writing code is fast, this is the biggest benefit of not doing command-based the style of coding used when not doing command-based is the same style that many people are already familiar with Can write code in this way without being experienced in the programming language very easy to write TeleOp code We can handle when things are run directly, instead of having to go through the command scheduler Extra verbose Cons: Most teams use command-based pathplanner expects you to use command-based, using pathplanner requires extra effort A little difficult to write Auto code can accidentally create a conflict where 2 pieces of code tell 1 piece of hardware to do something Pros and cons of doing command based Pros: plenty of examples because most teams use command-based Very easy to write Auto code / sequential code Can avoid conflicts via the command requirments Well written command-based code looks really nice Uses factory functions and lambdas to run code (makes for concise code, concise code can be easier to follow) Cons: Hard to work with when crunched for time Command scheduler is confusing TeleOp code can be convoluted hard to write code that uses multiple subsystems at the same time Uses factory functions and lambdas to run code (these are very confusing, even more for new programmers)","title":"On Command Based Programming"},{"location":"philosophy/on-command-based-programming/#pros-and-cons-of-not-doing-command-based","text":"","title":"Pros and cons of NOT doing command-based"},{"location":"philosophy/on-command-based-programming/#pros","text":"writing code is fast, this is the biggest benefit of not doing command-based the style of coding used when not doing command-based is the same style that many people are already familiar with Can write code in this way without being experienced in the programming language very easy to write TeleOp code We can handle when things are run directly, instead of having to go through the command scheduler Extra verbose","title":"Pros:"},{"location":"philosophy/on-command-based-programming/#cons","text":"Most teams use command-based pathplanner expects you to use command-based, using pathplanner requires extra effort A little difficult to write Auto code can accidentally create a conflict where 2 pieces of code tell 1 piece of hardware to do something","title":"Cons:"},{"location":"philosophy/on-command-based-programming/#pros-and-cons-of-doing-command-based","text":"","title":"Pros and cons of doing command based"},{"location":"philosophy/on-command-based-programming/#pros_1","text":"plenty of examples because most teams use command-based Very easy to write Auto code / sequential code Can avoid conflicts via the command requirments Well written command-based code looks really nice Uses factory functions and lambdas to run code (makes for concise code, concise code can be easier to follow)","title":"Pros:"},{"location":"philosophy/on-command-based-programming/#cons_1","text":"Hard to work with when crunched for time Command scheduler is confusing TeleOp code can be convoluted hard to write code that uses multiple subsystems at the same time Uses factory functions and lambdas to run code (these are very confusing, even more for new programmers)","title":"Cons:"},{"location":"philosophy/on-package-management/","text":"On Package Management Managing dependencies when programming is tricky, and Python doesn't make it fun. Python standardizes Pip and the way it works, but it's not terribly complex and doesn't handle more advanced concepts like Virtual Environments. It can also break packages (system installed or otherwise) very easily, and despite being usable in most cases, further extension is necessary. I have decided that an extended package manager is needed to effectively work with Python and FRC code, and so I write this to expand on what and how to use the abstractions defined in our standards. Pipenv vs Pip I decided, after a little searching, that Pipenv complied with the warrants that an FRC and RobotPy project needs. In terms of functionality, Pipenv has a few things that, in my opinion, make it a little more usable for this purpose. Pipenv, among other things, uses a standard configuration to define packages and configuration for build and deploy scripts. It also automatically handles the creation and management of Virtual Environments, which prevents Robot Code and dependencies from interfering with anything else installed on any given computer. See below figure 1 and figure 2 which show the pros and cons of Pip, briefly summarized. There are many more nuances that are necessary to understand, but those are outlined in programming/pipenv Pipenv (Figure 1) Pros Cons Virtual Environments Much more complex than Pip Scripts in Configuration More documentation work necessary (nonstandard) Pip (Figure 2) Pros Cons Simple and easy to use Can easily break system HIGHLY documented and used in RobotPy/WPI docs Lacks certain configuration features Why not Poetry, PDM, etc? I chose Pipenv on a whim, honestly. But after reading about some features of Pipenv when compared with Poetry and some others, I found that it would have an easy enough learning curve and has sufficient features when compared with it's contemporaries in other languages (see NPM, Cargo, etc) zach is making me write this - kay","title":"On Package Management"},{"location":"philosophy/on-package-management/#on-package-management","text":"Managing dependencies when programming is tricky, and Python doesn't make it fun. Python standardizes Pip and the way it works, but it's not terribly complex and doesn't handle more advanced concepts like Virtual Environments. It can also break packages (system installed or otherwise) very easily, and despite being usable in most cases, further extension is necessary. I have decided that an extended package manager is needed to effectively work with Python and FRC code, and so I write this to expand on what and how to use the abstractions defined in our standards.","title":"On Package Management"},{"location":"philosophy/on-package-management/#pipenv-vs-pip","text":"I decided, after a little searching, that Pipenv complied with the warrants that an FRC and RobotPy project needs. In terms of functionality, Pipenv has a few things that, in my opinion, make it a little more usable for this purpose. Pipenv, among other things, uses a standard configuration to define packages and configuration for build and deploy scripts. It also automatically handles the creation and management of Virtual Environments, which prevents Robot Code and dependencies from interfering with anything else installed on any given computer. See below figure 1 and figure 2 which show the pros and cons of Pip, briefly summarized. There are many more nuances that are necessary to understand, but those are outlined in programming/pipenv","title":"Pipenv vs Pip"},{"location":"philosophy/on-package-management/#pipenv-figure-1","text":"Pros Cons Virtual Environments Much more complex than Pip Scripts in Configuration More documentation work necessary (nonstandard)","title":"Pipenv (Figure 1)"},{"location":"philosophy/on-package-management/#pip-figure-2","text":"Pros Cons Simple and easy to use Can easily break system HIGHLY documented and used in RobotPy/WPI docs Lacks certain configuration features","title":"Pip (Figure 2)"},{"location":"philosophy/on-package-management/#why-not-poetry-pdm-etc","text":"I chose Pipenv on a whim, honestly. But after reading about some features of Pipenv when compared with Poetry and some others, I found that it would have an easy enough learning curve and has sufficient features when compared with it's contemporaries in other languages (see NPM, Cargo, etc) zach is making me write this - kay","title":"Why not Poetry, PDM, etc?"},{"location":"philosophy/on-the-importance-of-documentation/","text":"If everyone on the team suddenly disappeared and were replaced with someone with no experience, would they be able to pick up where you left off? would they have to learn everything from scratch? Documenting what you do and what you learn is VERY important for the success of the team. Future members of the team should not have to go through all of the experiences that you went through to get to your knowledge level.","title":"On the Importance of Documentation"},{"location":"programming/docs-reference/","text":"Documentation Reference All documentation for hardware should be from the official docs, as listed below:","title":"Documentation Reference"},{"location":"programming/docs-reference/#documentation-reference","text":"All documentation for hardware should be from the official docs, as listed below:","title":"Documentation Reference"},{"location":"programming/getting-started/","text":"","title":"Getting Started"},{"location":"programming/pipenv/","text":"Package Management with Pipenv","title":"Package Management with Pipenv"},{"location":"programming/pipenv/#package-management-with-pipenv","text":"","title":"Package Management with Pipenv"}]}